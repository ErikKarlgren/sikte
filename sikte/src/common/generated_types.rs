/// Generated types from libbpf-rs skeleton
///
/// This module provides a bridge between the auto-generated types from libbpf-rs
/// and the rest of the codebase. It re-exports generated types with conventional
/// naming and adds helper methods for working with tagged unions.
use plain::Plain;

// Include generated skeleton to access types module
mod sikte_skel {
    include!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/src/bpf/sikte.skel.rs"
    ));
}

// Re-export generated types with capitalized names to match Rust conventions
pub use sikte_skel::types::{syscall_data as SyscallData, syscall_state as SyscallState};

pub type PidT = i32;

/// Syscall state tag constants (matching C enum values)
/// These are not generated by libbpf-rs since C enums are just constants
pub mod syscall_state_tag {
    pub const AT_ENTER: u32 = 0;
    pub const AT_EXIT: u32 = 1;
}

// Implement Plain trait for zero-copy deserialization from ring buffers
// SAFETY: These types are #[repr(C)] and generated from C structs with BTF
unsafe impl Plain for SyscallData {}
unsafe impl Plain for SyscallState {}

/// Extension trait for SyscallState to provide helper methods
pub trait SyscallStateExt {
    /// Get syscall ID if this is an AT_ENTER state
    fn syscall_id(&self) -> Option<i64>;

    /// Get syscall return value if this is an AT_EXIT state
    fn syscall_ret(&self) -> Option<i64>;
}

impl SyscallStateExt for SyscallState {
    fn syscall_id(&self) -> Option<i64> {
        if self.tag == syscall_state_tag::AT_ENTER {
            Some(unsafe { self.data.at_enter.syscall_id })
        } else {
            None
        }
    }

    fn syscall_ret(&self) -> Option<i64> {
        if self.tag == syscall_state_tag::AT_EXIT {
            Some(unsafe { self.data.at_exit.syscall_ret })
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_syscall_data_layout() {
        // Verify size matches expectations (should be same as manual types)
        assert_eq!(std::mem::size_of::<SyscallData>(), 32);
        assert_eq!(std::mem::align_of::<SyscallData>(), 8);
    }

    #[test]
    fn test_syscall_state_tagged_union() {
        use sikte_skel::types::{__anon_3, __anon_4, syscall_state_data};

        // Test AT_ENTER state
        let state = SyscallState {
            tag: syscall_state_tag::AT_ENTER,
            _padding: 0,
            data: syscall_state_data {
                at_enter: __anon_3 { syscall_id: 42 },
            },
        };
        assert_eq!(state.tag, syscall_state_tag::AT_ENTER);
        assert_eq!(state.syscall_id(), Some(42));
        assert_eq!(state.syscall_ret(), None);

        // Test AT_EXIT state
        let state = SyscallState {
            tag: syscall_state_tag::AT_EXIT,
            _padding: 0,
            data: syscall_state_data {
                at_exit: __anon_4 { syscall_ret: -1 },
            },
        };
        assert_eq!(state.tag, syscall_state_tag::AT_EXIT);
        assert_eq!(state.syscall_id(), None);
        assert_eq!(state.syscall_ret(), Some(-1));
    }
}
